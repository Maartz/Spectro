# Spectro ORM — Full Codebase Audit
**Date:** 2026-02-20
**Version audited:** main branch (~v0.3.0)
**Auditors:** 4 specialized agents (Swift Concurrency, PostgreSQL/DB, Architecture/API, Test Quality)

---

## Executive Summary

The audit surfaced **4 categories** of issues across **4 domains**. The headline findings:

1. **The relationship system is entirely non-functional.** `SpectroLazyRelation.load()` throws `notImplemented` on all three paths. `RelationshipBatchLoader.loadBatch` always returns empty. The N+1 prevention advertised in the README does not work.
2. **The query parameter placeholder system is broken.** All conditions emit `$1`. The `&&`/`||` renumbering uses substring replacement that corrupts parameters for queries with 9+ combined conditions, and for any `IN`/`BETWEEN` clause composed with other conditions.
3. **The codebase is not Swift 6 ready.** `TransactionContext: Sendable` wraps a non-Sendable `PostgresConnection`. `[String: Any]` crosses actor boundaries. `SpectroError` carries `Any?` values. Strict concurrency is not enabled in `Package.swift`.
4. **The migration system parses Swift source files at runtime.** This is non-functional in any deployment without source files (Docker, CI artifacts).

---

## Domain 1: Swift Concurrency & Actor Safety

### Critical

**C1-1 — Task leak + actor isolation violation in `transaction(_:)`**
`DatabaseConnection.swift` — `transaction(_:)` method

Spawns an unstructured `Task { }` inside an `EventLoopFuture` closure. The task inherits the actor's isolation context while NIO waits on a separate event loop. Actor state can change between the `Task` being scheduled and completing. In Swift 6 strict mode, passing `TransactionContext` (containing `PostgresConnection`) into the task is a `Sendable` violation.

Fix: Replace the promise bridge with a fully async implementation:
```swift
public func transaction<T: Sendable>(
    _ work: @escaping @Sendable (TransactionContext) async throws -> T
) async throws -> T {
    guard !isShutdown else { throw ... }
    let conn = try await pools.requestConnection().get()
    defer { pools.releaseConnection(conn) }
    try await conn.query("BEGIN ISOLATION LEVEL READ COMMITTED")
    do {
        let result = try await work(TransactionContext(connection: conn))
        try await conn.query("COMMIT")
        return result
    } catch {
        try? await conn.query("ROLLBACK")
        throw SpectroError.transactionFailed(underlying: error)
    }
}
```

---

**C1-2 — `TransactionContext: Sendable` wraps non-Sendable `PostgresConnection`**
`DatabaseConnection.swift` — `TransactionContext` struct

`PostgresConnection` is a NIO-managed class that is not `Sendable`. Declaring `TransactionContext: Sendable` while storing one is incorrect and a Swift 6 compiler error under strict checking.

Fix: Remove the `Sendable` conformance, or redesign `TransactionContext` to not directly hold a `PostgresConnection`.

---

**C1-3 — Actor `deinit` reads isolated property `isShutdown`**
`DatabaseConnection.swift` — `deinit`

```swift
deinit {
    if !isShutdown {   // actor-isolated read in deinit — isolation violation
        pools.shutdown()
        try? eventLoopGroup.syncShutdownGracefully()
    }
}
```
In Swift 6, `deinit` runs outside the actor's executor. Reading actor-isolated state from `deinit` is a data race. `syncShutdownGracefully()` also blocks the thread, which may be the main thread.

Fix: Remove `deinit`. Document that `shutdown()` must be called explicitly.

---

**C1-4 — Strict concurrency not enabled — bugs are invisible at compile time**
`Package.swift`

The package targets `swift-tools-version: 5.9` with no `swiftLanguageVersions: [.v6]` and no `.enableExperimentalFeature("StrictConcurrency")`. All Sendable violations above are warnings or silently suppressed. The codebase cannot be considered Swift 6 ready until these are enabled and the resulting errors resolved.

Fix:
```swift
.target(name: "Spectro", swiftSettings: [
    .swiftLanguageVersion(.v6)
])
```

---

**C1-5 — `SchemaRegistry` reflects over non-Sendable property wrapper types**
`SchemaRegistry.swift` — `extractMetadata`

Calls `T()` and uses `Mirror` to reflect over property wrappers that may contain `SpectroLazyRelation` (non-Sendable). Under strict concurrency, reflecting non-Sendable types from within an actor context produces warnings/errors. Every query-time metadata access requires two actor hops (caller → `GenericDatabaseRepo` → `SchemaRegistry`).

Fix: Perform registration eagerly at startup and cache per-type. Replace `Any.Type` in `FieldInfo` with a `FieldType` enum (see Architecture section).

---

### Major

**C1-6 — `LoadState.error(Error)` — `Error` is not `Sendable`**
`SpectroLazyRelation.swift`

```swift
public enum LoadState: Sendable {
    case error(Error)   // 'any Error' is not Sendable
}
```
Fix: `case error(any Error & Sendable)`

**C1-7 — `update` API uses `[String: Any]` — not `Sendable`**
`GenericDatabaseRepo.swift`, `Repo.swift`

Passing `[String: Any]` across the actor boundary is a Swift 6 violation. `Any` is not `Sendable`.
Fix: Replace with `[String: any Sendable]` at minimum, or a typed changeset.

**C1-8 — `SpectroLazyRelation.load()` throws `notImplemented` on all paths**
`SpectroLazyRelation.swift`

All three load methods (`loadHasMany`, `loadHasOne`, `loadBelongsTo`) throw unconditionally. The relationship system is non-functional through the public API.

**C1-9 — `execute` returns hardcoded `1` for affected row count**
`DatabaseConnection.swift`

Always returns `1` regardless of actual PostgreSQL `commandTag`. Makes it impossible to detect "record not found" on UPDATE/DELETE.

### Minor

**C1-10** — `nonisolated var config` is correctly done (positive pattern — no issue).
**C1-11** — `withCheckedThrowingContinuation` correctly used (not unsafe variant — positive pattern).
**C1-12** — `FieldInfo.type: Any.Type` is not `Sendable`; replace with a `FieldType` enum.
**C1-13** — Property wrapper setters that silently ignore writes are footguns (no concurrency bug, but debugging pain).

---

## Domain 2: PostgreSQL & Database Correctness

### Critical

**DB-1 — All query conditions emit `$1`; parameter renumbering is broken for 9+ parameters**
`Query.swift` — all `QueryField` operator overloads + `&&`/`||`

Every operator hardcodes `$1`:
```swift
QueryCondition(sql: "\(lhs.name.snakeCase()) = $1", parameters: [...])
```
The composition operators renumber via ascending-order string replacement:
```swift
for i in 1...rhs.parameters.count {
    adjustedRightSQL = adjustedRightSQL.replacingOccurrences(of: "$\(i)", with: "$\(leftParameterCount + i)")
}
```
This corrupts `$10` → `$[n+1]0` because `$1` is replaced first (substring match). Any query with more than 9 combined parameters silently binds wrong values. Silent data corruption, not a crash.

Fix: Use placeholder-free SQL during condition construction (e.g., `?` sentinel) and do a single-pass renumbering sweep in `buildSQL()`. Never renumber during condition composition.

---

**DB-2 — Table names, column names, join conditions interpolated without quoting**
`Query.swift` — `buildSQL()`, `buildJoinClause()`, `buildOrderClause()`

```swift
var sql = "SELECT \(selectClause) FROM \(table)"
```
None of these identifiers are double-quoted. PostgreSQL reserved words used as table/column names (`user`, `order`, `table`, `comment`) will produce parse errors. An unquoted identifier that contains mixed case will be silently lowercased by PostgreSQL.

Fix: Quote all identifiers: `"\"\(name.replacingOccurrences(of: "\"", with: "\"\""))\""`.

---

**DB-3 — `JoinQuery` and `GenericDatabaseRepo` call `fatalError` on user errors**
`JoinQuery.swift`, `GenericDatabaseRepo.swift`

`fatalError("No join found for schema type...")` and `fatalError` on missing `SchemaBuilder` conformance crash the process. In a server context this kills all active connections.

Fix: Replace with `throw SpectroError.invalidQuery(...)` everywhere.

---

**DB-4 — `ConditionValue` auto-detects JSONB by checking if string starts with `{`**
`ConditionValue.swift`

```swift
if string.hasPrefix("{") { return .jsonb(string) }
```
Any ordinary string starting with `{` (address fragments, template strings, Swift dictionary descriptions) is silently mistyped as JSONB. PostgreSQL rejects non-JSON data sent with the `jsonb` wire type, producing a confusing runtime error.

Fix: Remove the heuristic. Require callers to explicitly use `.jsonb(string)`.

---

**DB-5 — `LIMIT`/`OFFSET` interpolated without non-negative validation**
`Query.swift` — `buildLimitClause()`

`LIMIT -1` and `OFFSET -1` are invalid PostgreSQL. No bounds check exists.

Fix: Guard `count >= 0` in `limit(_:)` and `offset(_:)` builder methods.

---

### Major

**DB-6 — `PreloadQuery.preloadRelationship` is a stub — silently returns unchanged entities**
`PreloadQuery.swift`

```swift
// For now, return entities unchanged until we implement the batch loading
return entities
```
The entire preload / N+1 prevention API is hollow. No error, no warning, wrong data.

**DB-7 — `&&`/`||` renumbering double-replaces: `BETWEEN $1 AND $2` with ascending iteration**
`Query.swift` — `&&`/`||` operators

See DB-1. Iterating i=1 then i=2 means the replacement of `$1` in iteration 1 may corrupt the `$2` written in iteration 2 if the SQL for the second condition is `$1 AND $2` and the renumbering writes `$2` then `$3`. The iteration order must be descending.

**DB-8 — Transaction does not pin a single connection from the pool**
`GenericDatabaseRepo.swift`

`BEGIN` is issued on one pool connection; subsequent queries inside the closure may acquire different connections. The transaction wraps nothing.

Fix: Use `pool.withConnection { conn in ... }` to hold a single connection for the entire closure.

**DB-9 — `SQLStatementParser` does not handle inline `--` comments or block `/* */` comments**
`SQLStatementParser.swift`

Only full-line `--` comments are stripped. A `;` inside `-- comment` or `/* ... */` prematurely terminates a statement during migration parsing.

**DB-10 — `MigrationManager` parses Swift source files as text at runtime**
`MigrationManager.swift`

Searches for `func up() -> String {` in `.swift` source files. Non-functional in any deployment without source files (Docker containers, release builds, CI artifacts).

Fix: Use plain `.sql` files as bundle resources, or Swift types registered at startup.

**DB-11 — `IN`/`NOT IN` always start placeholder numbering at `$1`**
`Query.swift` — `in(_:)`, `notIn(_:)`

```swift
let placeholders = (1...valueArray.count).map { "$\($0)" }.joined(separator: ", ")
```
Same root cause as DB-1; compounds with the broken renumbering logic.

### Minor

**DB-12** — `OrderByField` struct is dead code (never referenced; `Query` uses inline `OrderByClause`).
**DB-13** — `selectedFields: Set<String>` destroys column ordering in `SELECT` clause.
**DB-14** — Date operators (`isToday()`, etc.) emit unqualified column names, ambiguous in JOINs.
**DB-15** — `MigrationRecord` has no application-level deduplication for concurrent startup.
**DB-16** — `DatabaseConfiguration.fromEnvironment()` silently uses defaults for missing vars.
**DB-17** — `extractRelationshipName` parses `String(describing: keyPath)` — unstable ABI string.

---

## Domain 3: Architecture & API Design

### Critical

**A-1 — `SchemaMapper.applyValuesViaReflection` throws `notImplemented` unconditionally**
`SchemaMapper.swift`

Any `Schema` type that does not implement `SchemaBuilder.build(from:)` gets a runtime `.notImplemented` error when rows are fetched. The ORM does not work generically without manual boilerplate on every model. Combining this with property wrappers (which can't be mutated via Mirror) means there is no zero-boilerplate path.

Fix: A `@Schema` macro (Swift 5.9 is already required) should synthesize `build(from:)` at compile time from property wrapper declarations.

---

**A-2 — `DynamicSchema` is a mutable reference type conforming to value-semantic `Schema`**
`DynamicSchema.swift`

`DynamicSchema` is a `class` with `attributes: [String: Any]` — mutable, non-`Sendable`, reference semantics. Conforms to `Schema` which assumes value semantics and `Sendable`. `setAttribute` mutates state with no synchronization.

Fix: Remove `DynamicSchema`. If dynamic schemas are needed, give them a separate, non-`Schema` type and a dedicated repository path.

---

**A-3 — `RepositoryError` is internal — consumers cannot catch it**
`RepositoryError.swift`

No `public` modifier. Callers outside the module cannot catch `RepositoryError` specifically. `catch let e as RepositoryError` is silently unreachable from consumer code.

Fix: Delete `RepositoryError`, migrate all throw sites to `SpectroError`.

---

**A-4 — `Migration` protocol: `up()`/`down()` are synchronous, return raw `String`**
`Migration.swift`

No transaction context, no async, no multi-statement support, no ability to call Swift code in migrations.

Fix:
```swift
public protocol Migration {
    var version: String { get }
    func up(on database: any SQLDatabase) async throws
    func down(on database: any SQLDatabase) async throws
}
```

---

**A-5 — `SchemaRegistry.shared` is a global singleton — untestable**
`SchemaRegistry.swift`

No injection point. Tests cannot substitute a registry, preload metadata, or isolate registrations between runs. Also silently drops `Optional<T>` fields with `// For now, we'll skip these`.

Fix: Inject `SchemaRegistry` through `Spectro`'s constructor. Add `Optional` column support.

---

### Major

**A-6 — `KeyPathFieldExtractor` parses `String(describing: keyPath)` — unstable**
`Schema.swift`

`String(describing: \User.name)` → `"\User.name"` is an implementation detail, not an ABI guarantee. Has changed across Swift compiler versions.

Fix: A `@Schema` macro that generates a `static var fieldName: String` for each property at compile time.

**A-7 — `update` API uses `[String: Any]` — completely untyped**
`Repo.swift`, `Spectro.swift`

No compile-time validation that keys are valid field names or that values match field types.

Fix: KeyPath-based setter: `update(User.self, id: id, set: (\User.name, "Alice"))`.

**A-8 — `DatabaseOperation` protocol takes `[PostgresData]` — couples protocol to PostgresNIO**
`DatabaseOperation.swift`

Prevents mocking in tests without importing PostgresNIO. Prevents any non-Postgres backend.

**A-9 — Product `SpectroKit` vs target `Spectro` naming mismatch**
`Package.swift`

Users add `SpectroKit` as a dependency but write `import Spectro`. Confusing by design.

Fix: Rename the library product to `Spectro`.

**A-10 — `SpectroError` carries `value: Any?` — breaks `Sendable`**
`SpectroError.swift`

`case invalidParameter(name: String, value: Any?)` and `case invalidData(field: String, value: Any?)` in a `Sendable`-conforming enum.

Fix: Use `value: String?` (the string representation).

**A-11 — `SchemaBuilder`/`SchemaMapper` have two parallel, non-composing code paths**
`SchemaBuilder.swift`, `SchemaMapper.swift`

`SchemaMapper.mapRow` tries `MutableSchema`, falls back to `applyValuesViaReflection` (which throws). `SchemaBuilder.build(from:)` is the right path but `SchemaMapper` doesn't exclusively delegate to it.

Fix: Collapse to one strategy: `SchemaMapper` delegates exclusively to `SchemaBuilder.build(from:)`. Remove the reflection fallback.

### Minor

**A-12** — `insuficientPrivileges` (typo) in `DatabaseError` — public API spelling error, breaking to fix post-release.
**A-13** — `MigrationError` doesn't conform to `LocalizedError` — inconsistent with `DatabaseError`.
**A-14** — `Inflector` tests are `#if DEBUG` only — not in the test target.
**A-15** — `Query` parameter index management during condition combination is manual and fragile (see DB-1).
**A-16** — `snakeCase()` regex fails on consecutive uppercase: `userID` → `user_i_d`, `URLString` → `u_r_l_string`. Fix: add second regex pass for `([A-Z]+)([A-Z][a-z])` → `$1_$2`.
**A-17** — `any Repo` existential in `Repo.transaction`'s own signature — use a concrete `TransactionContext` type instead.
**A-18** — Example schemas (`User`, `Product`, `Post`, `Comment`, `Tag`, `PostTag`, `Profile`) are public library types. Move to test target or a separate examples package.

---

## Domain 4: Test Quality & Coverage

### Critical Gaps

**T-1 — `SpectroLazyRelation.load()` has zero tests via the public `@HasMany`/`@HasOne` API**
All test coverage uses a low-level bypass (`user.loadHasMany(Post.self, foreignKey:, using:)`). The actual property wrapper load path is untested and provably broken.

**T-2 — `RelationshipBatchLoader` has zero tests and is a stub returning empty results**

**T-3 — `TupleQuery` / `Query.select()` — zero coverage**
Contains a `as! Result` force-cast in `mapRowToTuple` that will crash at runtime.

**T-4 — `MigrationManager` — zero coverage**
All of: `ensureMigrationTableExists`, `runMigrations`, `runRollback`, `discoverMigrations`, `loadMigrationContent`, `getMigrationStatuses` are untested.

**T-5 — Compound `&&`/`||` conditions with 9+ parameters — never tested**
The `$1` renumbering bug (DB-1) is invisible without a test that composes >9 parameters.

**T-6 — All string-filter operators untested**: `.like()`, `.ilike()`, `.notLike()`, `.startsWith()`, `.endsWith()`, `.contains()`, `.in()`, `.notIn()`, `.between()`, `.isNull()`, `.isNotNull()`

**T-7 — `leftJoin`, `rightJoin`, `joinThrough` — zero coverage**

**T-8 — Round-trip type coercion never verified for `Bool`, `Double`, `Date`**

### Reliability Issues

**T-9 — `TestSetup.getSpectro()` is a non-actor static mutable — data race**
`RelationshipTests` and `DebugRelationshipTest` call it from async contexts without `.serialized`. Swift Testing runs suites in parallel by default.

Fix: Replace with an actor, or mark all suites `.serialized`.

**T-10 — No per-test cleanup in `RelationshipTests` and `DebugRelationshipTest`**
Rows from previous tests bleed through. Count assertions are order-dependent.

**T-11 — 200ms `Task.sleep` in `TestDatabaseState.initializeOnceInternal()`**
PostgreSQL DDL is transactional and immediately consistent. This sleep is pure latency with no safety benefit.

**T-12 — `testCleanup()` is a named test, not a teardown hook**
Relies on Swift Testing running tests in declaration order, which is an implementation detail, not a guarantee.

### Quality Issues

**T-13 — `DebugRelationshipTest.swift` is exploratory debug code — should be deleted**
Emoji-laden print statements, no cleanup, duplicates `RelationshipTests` coverage exactly.

**T-14 — `#expect(Bool(true))` in catch blocks is a no-op assertion**
`CoreFunctionalTests.testErrorHandling`. Fix: use `#expect(throws: SpectroError.self)`.

**T-15 — `testSQLInjectionProtection` does not verify injection was actually prevented**
Asserts `count >= 1` — passes even if injection partially succeeded.

**T-16 — `#expect(foreignKey.wrappedValue != UUID())` generates a new UUID every call**
`FunctionalTests.testPropertyWrappers`. Will pass regardless of what `wrappedValue` returns.

**T-17 — `>=` count assertions mask leftover rows from prior tests**
`testBasicQueries` uses `>= 2`, `>= 1`. Assert exact counts after guaranteed clean state.

### Coverage Summary

| Component | Coverage |
|---|---|
| Spectro instance creation | Medium |
| `GenericDatabaseRepo` CRUD | Medium (happy path only) |
| `GenericDatabaseRepo.transaction` | Low |
| `Query.where` (simple `==`, `>`) | Medium |
| `Query.where` (compound, >2 params) | None |
| `Query.orderBy` (desc, multi-field) | None |
| `Query.limit` / `offset` | None |
| `Query.select` / `TupleQuery` | **None** |
| `Query.join` (inner) | Low |
| `Query.leftJoin` / `rightJoin` | **None** |
| `Query.joinThrough` | **None** |
| String filter operators | **None** |
| `Query.in` / `between` / null ops | **None** |
| `Query.preload` / `PreloadQuery` | **None** |
| `SpectroLazyRelation` state machine | Low |
| `SpectroLazyRelation.load()` (public API) | **None** |
| `RelationshipBatchLoader` | **None** |
| Low-level `loadHasMany/One/BelongsTo` | Medium |
| `MigrationManager` (all methods) | **None** |
| `SchemaBuilder.build(from:)` type coercion | Low |
| `SchemaMapper` | None (indirect only) |
| `SchemaRegistry` | **None** |
| `snakeCase()` edge cases | Low |
| Many-to-many (`PostTag`) | **None** |

---

## Prioritized Fix List

### P0 — Fix Before Any Public Use

| # | Issue | Domain |
|---|---|---|
| 1 | Parameter placeholder system (`$1` everywhere + broken renumber) | DB |
| 2 | `fatalError` in `JoinQuery` and `GenericDatabaseRepo` | DB |
| 3 | `SpectroLazyRelation.load()` + `RelationshipBatchLoader` stubs | Concurrency / DB |
| 4 | `RepositoryError` is internal — consumers can't catch it | Architecture |
| 5 | Quote all SQL identifiers (table names, column names) | DB |
| 6 | `JSONB` auto-detection by `{` prefix | DB |

### P1 — Fix Before v1.0

| # | Issue | Domain |
|---|---|---|
| 7 | Enable Swift 6 strict concurrency; fix resulting errors | Concurrency |
| 8 | `TransactionContext: Sendable` with non-Sendable `PostgresConnection` | Concurrency |
| 9 | `Task { }` inside `EventLoopFuture` in `transaction(_:)` | Concurrency |
| 10 | Remove `deinit` that accesses isolated state | Concurrency |
| 11 | Migration system: replace source-text parsing with SQL files or registered types | DB / Architecture |
| 12 | `update([String: Any])` → typed changeset | Architecture |
| 13 | `DynamicSchema` class conforming to value-semantic `Schema` | Architecture |
| 14 | `SchemaRegistry` singleton → injected instance | Architecture |
| 15 | `@Schema` macro to synthesize `build(from:)` | Architecture |
| 16 | Fix `TestSetup` data race + per-test cleanup | Tests |
| 17 | Write `QueryBuilderTests` covering untested operators and compound conditions | Tests |
| 18 | Write `MigrationManager` tests | Tests |
| 19 | Delete `DebugRelationshipTest.swift` | Tests |

### P2 — Polish

| # | Issue |
|---|---|
| 20 | Fix `insuficientPrivileges` typo (breaking change post-release) |
| 21 | Fix `snakeCase()` for consecutive uppercase (`userID`, `URLString`) |
| 22 | Move example schemas out of the library product |
| 23 | Rename product `SpectroKit` → `Spectro` |
| 24 | `MigrationError` → add `LocalizedError` conformance |
| 25 | `execute` returns actual affected row count (not hardcoded `1`) |
| 26 | Fix `testCleanup()` → proper teardown, not a named test |
| 27 | Remove 200ms sleep from `TestDatabaseState` |

---

*Generated by 4 parallel audit agents on 2026-02-20.*
